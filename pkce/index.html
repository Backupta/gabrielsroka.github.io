<!doctype html>
<html lang="en">
<head>
<title>Users</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<style>
body, th, td {
    font-family: sans-serif;
    font-size: 13px;
}
th {
    text-align: left;
    font-weight: normal;
    background-color: #f0f0f0;
    padding: 6px;
}
tr:hover {
    background-color: #f0f0f0;
}
td {
    padding: 6px;
    border-bottom: 1px solid #eeeeee;
}
</style>
</head>
<body>
<div id=results></div>
<script>
// from https://developer.okta.com/blog/2019/05/01/is-the-oauth-implicit-flow-dead
// and  https://github.com/aaronpk/pkce-vanilla-js

// Configure your application and authorization server details
const baseUrl = 'https://gsroka-neto.oktapreview.com';
const config = {
    client_id: '0oatnwl9cotZ1xPph0h7',
    redirect_uri: `${location.origin}/pkce/`,
    authorization_endpoint: `${baseUrl}/oauth2/v1/authorize`,
    token_endpoint: `${baseUrl}/oauth2/v1/token`,
    requested_scopes: 'okta.groups.read okta.users.read'
};

// OAUTH REDIRECT HANDLING

// Handle the redirect back from the authorization server and
// get an access token from the token endpoint

const q = parseQueryString(location.search.substring(1));

if (q.error) {
    console.log(q.error + "\n\n" + q.error_description);
}

// If the server returned an authorization code, attempt to exchange it for an access token
if (q.code) {
    if (localStorage.getItem("pkce_state") != q.state) {
        alert("Invalid state");
    } else {
        // Exchange the authorization code for an access token
        sendPostRequest(config.token_endpoint, {
            grant_type: "authorization_code",
            code: q.code,
            client_id: config.client_id,
            redirect_uri: config.redirect_uri,
            code_verifier: localStorage.getItem("pkce_code_verifier")
        }, async function (request, body) {
            const r = await fetch(`${baseUrl}/api/v1/groups`, {headers: {Authorization: `Bearer ${body.access_token}`}});
            const groups = await r.json();
            const rows = '<tr><td>' + groups.map(g => g.profile.name).join('<tr><td>');
            results.innerHTML = '<table><tr><th>Name' + rows + '</table>'

            // Replace the history entry to remove the auth code from the browser address bar
            history.replaceState({}, null, "/pkce/index.html");
        }, function (request, error) {
            console.log(error.error + "\n\n" + error.error_description);
        });
    }

    // Clean these up since we don't need them anymore
    localStorage.removeItem("pkce_state");
    localStorage.removeItem("pkce_code_verifier");
} else {
    pkce();
}

async function pkce() {
    // Initiate the PKCE Auth Code flow
    const state = generateRandomString();
    localStorage.setItem("pkce_state", state);
    const code_verifier = generateRandomString();
    localStorage.setItem("pkce_code_verifier", code_verifier);
    const code_challenge = await pkceChallengeFromVerifier(code_verifier);
    const url = config.authorization_endpoint
        + "?response_type=code"
        + "&client_id=" + encodeURIComponent(config.client_id)
        + "&state=" + encodeURIComponent(state)
        + "&scope=" + encodeURIComponent(config.requested_scopes)
        + "&redirect_uri=" + encodeURIComponent(config.redirect_uri)
        + "&code_challenge=" + encodeURIComponent(code_challenge)
        + "&code_challenge_method=S256";
    location = url;
}


//////////////////////////////////////////////////////////////////////
// GENERAL HELPER FUNCTIONS

function sendPostRequest(url, params, success, error) {
    const request = new XMLHttpRequest();
    request.open('POST', url, true);
    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
    request.onload = function () {
        let body = {};
        try {
            body = JSON.parse(this.response);
        } catch (e) { }

        if (this.status == 200) {
            success(this, body);
        } else {
            error(this, body);
        }
    };
    request.onerror = function () {
        error(this, {});
    };
    const body = Object.keys(params).map(key => key + '=' + params[key]).join('&');
    request.send(body);
}

function parseQueryString(string) {
    if (string == "") { return {}; }
    const queryString = {};
    string.split("&").forEach(s => {
        const [name, value] = s.split("=");
        queryString[name] = value;
    });
    return queryString;
}


//////////////////////////////////////////////////////////////////////
// PKCE HELPER FUNCTIONS

// Generate a secure random string using the browser crypto functions
function generateRandomString() {
    const array = new Uint32Array(28);
    crypto.getRandomValues(array);
    return Array.from(array, dec => ('0' + dec.toString(16)).substr(-2)).join('');
}

// Calculate the SHA256 hash of the input text. 
// Returns a promise that resolves to an ArrayBuffer
function sha256(plain) {
    const encoder = new TextEncoder();
    const data = encoder.encode(plain);
    return crypto.subtle.digest('SHA-256', data);
}

function base64urlencode(str) {
    // Convert the ArrayBuffer to string using Uint8 array to convert to what btoa accepts.
    // btoa accepts chars only within ascii 0-255 and base64 encodes them.
    // Then convert the base64 encoded to base64url encoded
    //   (replace + with -, replace / with _, trim trailing =)
    return btoa(String.fromCharCode.apply(null, new Uint8Array(str)))
        .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

// Return the base64-urlencoded sha256 hash for the PKCE challenge
async function pkceChallengeFromVerifier(v) {
    const hashed = await sha256(v);
    return base64urlencode(hashed);
}
</script>
</body>
</html>
